<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NeoWs Asteroids — Earth Defense (Demo)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#071029; color:#e6f1ff; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
    #gameWrap { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; align-items:stretch; }
    #left { flex:1; position:relative; min-width:640px; background:#001028; border-radius:8px; overflow:hidden; box-shadow:0 6px 30px rgba(0,0,0,0.7); }
    canvas { display:block; width:100%; height:100%; background: radial-gradient(circle at center, #042033 0%, #00121a 60%, #000 100%); }
    #right { width:360px; display:flex; flex-direction:column; gap:12px; }
    .panel { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:8px; }
    h1 { margin:0 0 6px 0; font-size:18px; }
    .btn { display:inline-block; padding:8px 12px; border-radius:6px; background:#0b6; color:#012; cursor:pointer; user-select:none; margin-right:6px; font-weight:600; }
    .btn.alt { background:#39f; color:white; }
    .small { font-size:13px; opacity:0.9; }
    .hud { position:absolute; left:12px; top:12px; z-index:5; background:rgba(0,0,0,0.25); padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    #startOverlay { position:absolute; left:0; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(1,6,12,0.6), rgba(0,0,0,0.6)); z-index:10; }
    #startBox { width:720px; max-width:95%; background:rgba(4,18,28,0.95); padding:18px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); }
    .list { max-height:200px; overflow:auto; padding:6px; border-radius:6px; background:rgba(255,255,255,0.01); margin-top:8px; }
    .row { display:flex; justify-content:space-between; gap:8px; padding:6px 4px; border-bottom:1px dashed rgba(255,255,255,0.02); font-size:13px; }
    footer { font-size:12px; opacity:0.8; margin-top:8px; }
    .toggle { display:flex; gap:8px; align-items:center; }
    .kbd { display:inline-block; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.02); font-size:12px; }
    .score { font-weight:700; font-size:18px; color:#9ff; }
    .warning { color:#ffb3b3; font-weight:600; }
  </style>
</head>
<body>
  <div id="gameWrap">
    <div id="left" class="panel">
      <div class="hud" id="hud">
        <div>Time: <span id="time">--:--</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Mode: <span id="modeLabel">Human</span></div>
      </div>

      <canvas id="canvas"></canvas>

      <div id="startOverlay">
        <div id="startBox">
          <h1>Earth Defense — NeoWs Demo</h1>
          <div class="small">Survive for <strong>5 minutes</strong> against asteroids. Weapons: shield (E) and blaster (click). Move Earth with arrow keys or WASD or drag.</div>

          <div style="margin-top:12px;">
            <label>NASA API key</label><br/>
            <input id="apiKey" type="text" placeholder="Paste API key or use DEMO_KEY" style="width:100%; padding:8px; margin-top:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(0,0,0,0.2); color:#e6f1ff;" value="DEMO_KEY" />
          </div>

          <div style="margin-top:10px;">
            <button class="btn" id="scanBtn">Fetch Asteroids & Preview</button>
            <button class="btn alt" id="startBtn">Start Game</button>
            <label style="margin-left:10px;" class="small"><input id="aiToggle" type="checkbox" /> AI mode</label>
          </div>

          <div style="margin-top:12px;">
            <strong>Incoming asteroids (preview):</strong>
            <div class="list" id="neoList">No data yet — click "Fetch Asteroids & Preview".</div>
          </div>

          <footer>
            Note: This is a playable *approximation* that uses NeoWs data properties (size, approach distance, velocity) to seed game asteroids. Not a real orbital simulator.
          </footer>
        </div>
      </div>
    </div>

    <div id="right">
      <div class="panel">
        <h1>Controls</h1>
        <div class="small">
          <div><span class="kbd">W/A/S/D</span> / <span class="kbd">↑ ← ↓ →</span> — Move Earth</div>
          <div><span class="kbd">Mouse drag</span> — Drag Earth</div>
          <div><span class="kbd">E</span> — Shield (short cooldown)</div>
          <div><span class="kbd">Click</span> — Fire blaster</div>
        </div>
      </div>

      <div class="panel">
        <h1>Game settings</h1>
        <div class="small">
          <div>Spawn count: <input id="spawnCount" type="number" value="18" style="width:70px" /></div>
          <div style="margin-top:6px;">Shield duration: <input id="shieldDur" type="number" value="0.75" step="0.1" style="width:70px" /> s</div>
          <div style="margin-top:6px;">Game length (s): <input id="gameLength" type="number" value="300" style="width:70px" /> (300 = 5 min)</div>
        </div>
      </div>

      <div class="panel">
        <h1>AI Mode (explain)</h1>
        <div class="small">
          The AI is a simple heuristic agent: it continuously evaluates the most threatening asteroid (closest on collision course) and moves Earth away, triggers the shield when several asteroids cluster, and fires blaster at near/medium threats. This is a demo of how detection + automated response could operate; it's intentionally simple and transparent.
        </div>
      </div>

      <div class="panel">
        <h1>Status</h1>
        <div class="small">
          <div id="statusText">Idle</div>
          <div style="margin-top:8px;"><span class="warning">Tip:</span> Use your shield sparingly. Blaster splits asteroids into smaller ones which are faster but easier to deflect.</div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  NeoWs Earth Defense Demo
  - Save as single HTML file.
  - Replace API_KEY with your NASA API key (input box).
  - Serve from an HTTP server (e.g. python -m http.server) due to fetch CORS.
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
let W = canvas.width = canvas.clientWidth;
let H = canvas.height = canvas.clientHeight;
window.addEventListener('resize', () => { W = canvas.width = canvas.clientWidth; H = canvas.height = canvas.clientHeight; });

/* UI references */
const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const scanBtn = document.getElementById('scanBtn');
const neoListEl = document.getElementById('neoList');
const apiKeyInput = document.getElementById('apiKey');
const aiToggle = document.getElementById('aiToggle');
const spawnCountInput = document.getElementById('spawnCount');
const shieldDurInput = document.getElementById('shieldDur');
const gameLengthInput = document.getElementById('gameLength');
const statusText = document.getElementById('statusText');
const modeLabel = document.getElementById('modeLabel');
const timeLabel = document.getElementById('time');
const scoreLabel = document.getElementById('score');

let asteroids = [];
let bullets = [];
let particles = [];
let lastTime = performance.now();
let running = false;
let score = 0;
let gameEndAt = 0;
let shieldActive = false;
let shieldAvailable = true;
let shieldCooldown = 3.0;
let shieldExpiresAt = 0;

/* Earth object */
let Earth = {
  x: 0, y: 0, r: 28,
  vx: 0, vy: 0,
  speed: 260, // px/sec
  dragging: false,
};

/* Settings */
let settings = {
  spawnCount: parseInt(spawnCountInput.value||18),
  shieldDur: parseFloat(shieldDurInput.value||0.75),
  gameLength: parseInt(gameLengthInput.value||300),
};

/* AI state */
let aiMode = false;
let ai = {
  enabled: false,
  lastDecisionAt: 0,
  decisionInterval: 0.08
};

/* Utilities */
function rand(min, max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function now(){ return performance.now()/1000; }

/* Hash function for stable angles */
function simpleHash(s){
  let h=2166136261|0;
  for(let i=0;i<s.length;i++){ h = Math.imul(h ^ s.charCodeAt(i), 16777619); }
  return Math.abs(h);
}

/* Map NeoWs data -> game asteroid */
function neoToAsteroid(neo, index, total, canvasW, canvasH){
  // fields: estimated_diameter.meters. Use close_approach_data[0] for miss_distance/velocity if present.
  const diam = neo.estimated_diameter?.meters?.estimated_diameter_max || 50;
  const size = clamp(Math.sqrt(diam) * 1.2, 6, 80); // visual size
  const approach = neo.close_approach_data && neo.close_approach_data[0] ? neo.close_approach_data[0] : null;
  // Use miss_distance to choose spawn distance scale. If absent, random.
  const miss_km = approach ? parseFloat(approach.miss_distance?.kilometers || 8e6) : rand(1e4,1e7);
  const vel_kph = approach ? parseFloat(approach.relative_velocity?.kilometers_per_hour || 20000) : rand(5000,70000);
  // Map miss_km (range ~1e3..1e8) to spawn radius in screen coords.
  const maxRange = 1e7;
  const minRange = 3e3;
  const norm = clamp((miss_km - minRange) / (maxRange - minRange), 0, 1);
  const spawnRadius = clamp(120 + (1-norm) * Math.max(canvasW, canvasH) * 0.9, Math.max(canvasW,canvasH)*0.25, Math.max(canvasW,canvasH)*1.5);

  // stable angle from id
  const h = simpleHash(neo.id || (neo.name||'') );
  const angle = (h % 360) * Math.PI/180 + (index/total)*0.1;
  const cx = canvasW/2, cy = canvasH/2;
  // spawn x,y
  const x = cx + Math.cos(angle) * spawnRadius;
  const y = cy + Math.sin(angle) * spawnRadius;
  // velocity toward center scaled from vel_kph, with a little tangential component
  const speed = clamp(vel_kph/1000 * 0.7, 20, 330); // px/sec
  const dx = cx - x, dy = cy - y;
  const dist = Math.sqrt(dx*dx+dy*dy) || 1;
  const vx = (dx/dist) * speed + Math.cos(angle+Math.PI/2)*rand(-20,20);
  const vy = (dy/dist) * speed + Math.sin(angle+Math.PI/2)*rand(-20,20);

  return {
    id: neo.id,
    name: neo.name,
    size,
    x,y,vx,vy,
    mass: Math.max(1, size/12),
    hp: Math.max(1, Math.round(size/12)),
    // metadata for display
    miss_km, vel_kph, diam,
    color: 'rgba(200,200,200,0.95)',
  };
}

/* Fetch a sample of near-earth objects from NeoWs (browse endpoint) */
async function fetchNeos(apiKey, count=20){
  const endpoint = `https://api.nasa.gov/neo/rest/v1/neo/browse?api_key=${encodeURIComponent(apiKey)}&page=0&size=${count}`;
  const res = await fetch(endpoint);
  if(!res.ok) throw new Error('API failed: ' + res.status);
  const data = await res.json();
  return data.near_earth_objects || data;
}

/* Render utilities */
function drawEarth(x,y,r){
  // Earth: draw circle with gradient
  const g = ctx.createRadialGradient(x-r*0.3,y-r*0.3, r*0.2, x,y, r);
  g.addColorStop(0, '#66a3ff');
  g.addColorStop(0.55, '#2b7bd9');
  g.addColorStop(1, '#06326a');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();

  // simple continents (stylized)
  ctx.fillStyle = 'rgba(20,40,18,0.18)';
  ctx.beginPath();
  ctx.ellipse(x-r*0.15, y-r*0.08, r*0.32, r*0.18, -0.5, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x+r*0.15, y+r*0.05, r*0.22, r*0.14, 0.6, 0, Math.PI*2);
  ctx.fill();
}

/* Game loop */
function spawnFromNeos(neos, count){
  asteroids = [];
  const total = Math.min(count, neos.length);
  for(let i=0;i<total;i++){
    const neo = neos[i];
    asteroids.push(neoToAsteroid(neo, i, total, W, H));
  }
}

/* split asteroid into two smaller ones */
function splitAsteroid(a){
  if(a.size < 12) return false;
  const s1 = Object.assign({}, a);
  const s2 = Object.assign({}, a);
  s1.size = Math.max(6, a.size * 0.62);
  s2.size = Math.max(6, a.size * 0.46);
  s1.hp = Math.max(1, Math.round(s1.size/12));
  s2.hp = Math.max(1, Math.round(s2.size/12));
  // diverge velocities a bit
  s1.vx = a.vx + rand(-60,60);
  s1.vy = a.vy + rand(-60,60);
  s2.vx = a.vx + rand(-60,60);
  s2.vy = a.vy + rand(-60,60);
  s1.x = a.x + rand(-a.size*0.4,a.size*0.4);
  s1.y = a.y + rand(-a.size*0.4,a.size*0.4);
  s2.x = a.x + rand(-a.size*0.4,a.size*0.4);
  s2.y = a.y + rand(-a.size*0.4,a.size*0.4);
  // replace old with two new
  const idx = asteroids.indexOf(a);
  if(idx>=0) asteroids.splice(idx,1);
  asteroids.push(s1,s2);
  score += 8;
  return true;
}

/* Simple collision check between circles */
function circleCollide(ax,ay,ar,bx,by,br){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy <= (ar+br)*(ar+br); }

/* Main animation loop */
function tick(t){
  const dt = Math.min((t-lastTime)/1000, 0.05);
  lastTime = t;
  update(dt);
  render();
  if(running) requestAnimationFrame(tick);
}

/* Update physics and game state */
function update(dt){
  // update Earth via velocity
  Earth.x += Earth.vx * dt;
  Earth.y += Earth.vy * dt;
  // clamp inside canvas
  Earth.x = clamp(Earth.x, Earth.r, W-Earth.r);
  Earth.y = clamp(Earth.y, Earth.r, H-Earth.r);

  // gravity-ish attraction for asteroids towards their initial inward vector (they already have vx,vy)
  for(let a of asteroids){
    // slight acceleration inward (toward center)
    const cx = W/2, cy = H/2;
    const dx = cx - a.x, dy = cy - a.y;
    const dist = Math.sqrt(dx*dx+dy*dy) || 1;
    const pull = 10 * (a.mass/5); // small
    a.vx += (dx/dist)*pull*dt;
    a.vy += (dy/dist)*pull*dt;

    // friction / minor randomness
    a.vx *= (1 - Math.min(0.02, 0.005*dt));
    a.vy *= (1 - Math.min(0.02, 0.005*dt));

    // update position
    a.x += a.vx * dt;
    a.y += a.vy * dt;

    // wrap edges slightly: if too far beyond screen, pull back
    if(a.x < -200 || a.x > W+200 || a.y < -200 || a.y > H+200){
      // reposition to far edge toward center
      const angle = Math.atan2(cy - a.y, cx - a.x);
      a.x = cx + Math.cos(angle + rand(-0.2,0.2)) * Math.max(W,H) * 0.95;
      a.y = cy + Math.sin(angle + rand(-0.2,0.2)) * Math.max(W,H) * 0.95;
    }
  }

  // bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;
    if(b.life <= 0) bullets.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.life -= dt;
    p.alpha = p.life / p.max;
    if(p.life<=0) particles.splice(i,1);
  }

  // collisions: bullets vs asteroids
  for(let bi=bullets.length-1; bi>=0; bi--){
    const b = bullets[bi];
    for(let ai=asteroids.length-1; ai>=0; ai--){
      const a = asteroids[ai];
      if(circleCollide(b.x,b.y,4, a.x,a.y, a.size*0.6)){
        // bullet hits asteroid
        bullets.splice(bi,1);
        // spawn explosion particles
        spawnParticles(b.x,b.y, Math.min(18, Math.round(a.size/3)));
        // split or destroy
        if(!splitAsteroid(a)){
          // destroy
          asteroids.splice(ai,1);
          score += 12;
        }
        break;
      }
    }
  }

  // shield effect
  if(shieldActive){
    for(let a of asteroids){
      if(circleCollide(Earth.x,Earth.y, Earth.r*1.8, a.x,a.y, a.size*0.6)){
        // repel by flipping velocity component away from Earth center
        const dx = a.x - Earth.x, dy = a.y - Earth.y;
        const dist = Math.sqrt(dx*dx+dy*dy) || 1;
        const push = 350 + a.mass*40;
        a.vx = (dx/dist) * push + (a.vx*0.3);
        a.vy = (dy/dist) * push + (a.vy*0.3);
        // score for repelling
        score += 1;
      }
    }
    if(now() > shieldExpiresAt) { shieldActive = false; shieldAvailable = false; setTimeout(()=>{ shieldAvailable = true; }, shieldCooldown*1000); }
  }

  // asteroids hitting Earth
  for(let ai=asteroids.length-1; ai>=0; ai--){
    const a = asteroids[ai];
    if(circleCollide(a.x,a.y, a.size*0.6, Earth.x,Earth.y, Earth.r*0.9)){
      // impact — damage Earth — we'll simply penalize and destroy asteroid
      spawnParticles(a.x,a.y, Math.min(22, Math.round(a.size/2)));
      asteroids.splice(ai,1);
      score = Math.max(0, score - 25);
      // small knockback to Earth
      Earth.vx += (Earth.x - a.x) * 1.2;
      Earth.vy += (Earth.y - a.y) * 1.2;
    }
  }

  // Basic AI
  if(ai.enabled) runAi(dt);

  // Timer check
  const tnow = now();
  if(running && tnow >= gameEndAt){
    running = false;
    statusText.textContent = 'You survived! Game over.';
    showEndScreen(true);
  }

  // HUD update
  timeLabel.textContent = formatTime(Math.max(0, Math.round(gameEndAt - now())));
  scoreLabel.textContent = String(score);
}

/* Render world */
function render(){
  ctx.clearRect(0,0,W,H);
  // stars background
  drawStars();

  // center reference
  // Earth
  drawEarth(Earth.x, Earth.y, Earth.r);

  // shield
  if(shieldActive){
    ctx.beginPath();
    ctx.arc(Earth.x, Earth.y, Earth.r*1.8, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(100,180,255,0.08)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(140,210,255,0.35)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // asteroids
  for(let a of asteroids){
    ctx.save();
    ctx.translate(a.x, a.y);
    // rotate direction based on velocity
    const ang = Math.atan2(a.vy, a.vx);
    ctx.rotate(ang);
    // draw body
    ctx.beginPath();
    const s = a.size;
    // rough polygon
    ctx.moveTo(s*0.9,0);
    for(let i=1;i<7;i++){
      const th = i/7 * Math.PI*2;
      ctx.lineTo(Math.cos(th)*(s* (0.6+Math.random()*0.5)), Math.sin(th)*(s*(0.6+Math.random()*0.5)));
    }
    ctx.closePath();
    ctx.fillStyle = a.color;
    ctx.fill();
    // rim
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // small label for size (optional)
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(-s*0.5, s*0.6, s, 2);

    ctx.restore();
  }

  // bullets
  for(let b of bullets){
    ctx.beginPath();
    ctx.arc(b.x,b.y,4,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,220,120,1)';
    ctx.fill();
  }

  // particles
  for(let p of particles){
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = 'rgba(255,180,80,1)';
    ctx.fillRect(p.x,p.y,2,2);
    ctx.globalAlpha = 1;
  }
}

/* draw a nice subtle starfield */
let stars = [];
function makeStars(){
  stars = [];
  const count = Math.floor((W*H)/8000);
  for(let i=0;i<count;i++) stars.push({ x: rand(0,W), y: rand(0,H), s: rand(0.3,1.4), a: rand(0.02,0.9)});
}
function drawStars(){
  if(stars.length===0) makeStars();
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);
  for(let s of stars){
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${s.a})`;
    ctx.fillRect(s.x, s.y, s.s, s.s);
  }
}

/* spawn particles for effects */
function spawnParticles(x,y,n){
  for(let i=0;i<n;i++){
    particles.push({
      x,y,
      vx: rand(-120,120),
      vy: rand(-120,120),
      life: rand(0.3,0.9),
      max: rand(0.3,0.9),
      alpha:1
    });
  }
}

/* Input handling */
let keys = {};
window.addEventListener('keydown', e => {
  if(e.key==='Escape'){ if(running) { running=false; statusText.textContent='Paused'; startOverlay.style.display = 'flex'; } }
  if(e.key==='e' || e.key==='E'){ activateShield(); }
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  // if clicked near Earth, start dragging
  if(Math.hypot(mx-Earth.x,my-Earth.y) <= Earth.r+6){ Earth.dragging = true; } else {
    // fire blaster
    fireBullet(mx,my);
  }
});
window.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  if(Earth.dragging){ Earth.x = clamp(mx, Earth.r, W-Earth.r); Earth.y = clamp(my, Earth.r, H-Earth.r); }
});
window.addEventListener('mouseup', e => { Earth.dragging = false; });

/* Prevent context menu on right click inside canvas */
canvas.addEventListener('contextmenu', e => e.preventDefault());

/* Move Earth by keys each frame: we'll set velocity based on keys */
function applyPlayerInput(dt){
  let vx=0, vy=0;
  if(keys['w']||keys['arrowup']) vy -= 1;
  if(keys['s']||keys['arrowdown']) vy += 1;
  if(keys['a']||keys['arrowleft']) vx -= 1;
  if(keys['d']||keys['arrowright']) vx += 1;
  const mag = Math.sqrt(vx*vx+vy*vy);
  if(mag>0){
    vx = vx/mag * Earth.speed;
    vy = vy/mag * Earth.speed;
  }
  Earth.vx = vx;
  Earth.vy = vy;
}

/* Fire bullet from Earth toward target point */
function fireBullet(tx,ty){
  const dx = tx - Earth.x, dy = ty - Earth.y;
  const dist = Math.sqrt(dx*dx+dy*dy) || 1;
  const spd = 600;
  bullets.push({
    x: Earth.x + (dx/dist)*(Earth.r+6),
    y: Earth.y + (dy/dist)*(Earth.r+6),
    vx: dx/dist * spd,
    vy: dy/dist * spd,
    life: 2.0
  });
  score -= 0; // no penalty
}

/* Activate shield: short duration, cooldown */
function activateShield(){
  if(!shieldAvailable) return;
  shieldActive = true;
  shieldAvailable = false;
  shieldExpiresAt = now() + settings.shieldDur;
  // cooldown handled in update
}

/* AI agent: heuristic */
function runAi(dt){
  const t = now();
  if(t - ai.lastDecisionAt < ai.decisionInterval) return;
  ai.lastDecisionAt = t;

  // evaluate threats: asteroids closest to Earth predicted distance in short future
  let imminent = null, minPred = Infinity;
  for(let a of asteroids){
    // predict simple linear future position after 1.2s
    const px = a.x + a.vx*1.2;
    const py = a.y + a.vy*1.2;
    const d = Math.hypot(px - Earth.x, py - Earth.y);
    if(d < minPred){ minPred = d; imminent = a; }
  }

  // movement decision: move away from imminent threat
  if(imminent){
    const dx = Earth.x - imminent.x, dy = Earth.y - imminent.y;
    const mag = Math.hypot(dx,dy) || 1;
    Earth.vx = (dx/mag) * Earth.speed * 0.9;
    Earth.vy = (dy/mag) * Earth.speed * 0.9;
  } else {
    // slight drift toward center if no threats
    const dx = W/2 - Earth.x, dy = H/2 - Earth.y;
    const mag = Math.hypot(dx,dy) || 1;
    Earth.vx = (dx/mag) * Earth.speed * 0.3;
    Earth.vy = (dy/mag) * Earth.speed * 0.3;
  }

  // use shield if cluster of asteroids near
  const nearbyCount = asteroids.filter(a => Math.hypot(a.x - Earth.x, a.y - Earth.y) < Earth.r*4).length;
  if(nearbyCount >= 2 && shieldAvailable && !shieldActive){
    activateShield();
  }

  // fire blaster at the most central approaching asteroid within some range
  if(imminent){
    const d = Math.hypot(imminent.x - Earth.x, imminent.y - Earth.y);
    if(d < Math.max(W,H)*0.6){
      // aim and fire
      fireBullet(imminent.x + imminent.vx*0.4, imminent.y + imminent.vy*0.4);
    }
  }
}

/* Format seconds to mm:ss */
function formatTime(sec){
  const m = Math.floor(sec/60), s = Math.floor(sec%60);
  return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}

/* Start game with current asteroids */
function startGame(neos){
  settings.spawnCount = parseInt(spawnCountInput.value||18);
  settings.shieldDur = parseFloat(shieldDurInput.value||0.75);
  settings.gameLength = parseInt(gameLengthInput.value||300);
  ai.enabled = aiToggle.checked;
  modeLabel.textContent = ai.enabled ? 'AI' : 'Human';

  // reset world
  makeStars();
  bullets.length = 0; particles.length = 0;
  spawnFromNeos(neos, settings.spawnCount);
  // place Earth center
  Earth.x = W/2; Earth.y = H/2; Earth.vx = Earth.vy = 0;

  score = 0;
  shieldActive = false; shieldAvailable = true;
  gameEndAt = now() + settings.gameLength;
  running = true;
  startOverlay.style.display = 'none';
  statusText.textContent = 'Running';
  lastTime = performance.now();
  requestAnimationFrame(tick);
}

/* Show end screen overlay */
function showEndScreen(win){
  startOverlay.style.display = 'flex';
  const apiText = win ? `<strong>You survived!</strong> Score: ${score}` : `<strong>Game over</strong> Score: ${score}`;
  document.getElementById('startBox').querySelector('h1').innerHTML = apiText;
  // leave previous API key and list intact
}

/* Scanning/preview UI */
let lastNeos = null;
scanBtn.addEventListener('click', async ()=>{
  const key = apiKeyInput.value.trim() || 'DEMO_KEY';
  statusText.textContent = 'Fetching NeoWs data...';
  try{
    const data = await fetchNeos(key, 40);
    lastNeos = data;
    neoListEl.innerHTML = '';
    const sample = data.slice(0, Math.min(40, data.length));
    for(let i=0;i<sample.length;i++){
      const n = sample[i];
      const approach = n.close_approach_data && n.close_approach_data[0] ? n.close_approach_data[0] : null;
      const dkm = approach ? Number(approach.miss_distance.kilometers).toLocaleString() : '—';
      const vel = approach ? Number(approach.relative_velocity.kilometers_per_hour).toLocaleString() : '—';
      const row = document.createElement('div'); row.className='row';
      row.innerHTML = `<div style="flex:1">${n.name}</div><div class="small">d:${dkm} km</div><div class="small">${Math.round(n.estimated_diameter.meters.estimated_diameter_max)} m</div>`;
      neoListEl.appendChild(row);
    }
    statusText.textContent = 'Fetched ' + sample.length + ' objects. Previewed positions on start.';
  }catch(err){
    neoListEl.innerHTML = '<div class="small">Fetch failed: ' + err.message + '</div>';
    statusText.textContent = 'Fetch failed';
  }
});

/* Start button: if we don't have fetched neos, fetch before starting */
startBtn.addEventListener('click', async ()=>{
  const key = apiKeyInput.value.trim() || 'DEMO_KEY';
  ai.enabled = aiToggle.checked;
  modeLabel.textContent = ai.enabled ? 'AI' : 'Human';
  if(!lastNeos){
    try{
      statusText.textContent = 'Fetching NeoWs data...';
      lastNeos = await fetchNeos(key, 40);
      statusText.textContent = 'Fetched.';
    }catch(err){
      statusText.textContent = 'Fetch failed. Starting with generated asteroids.';
      lastNeos = generateFakeNeos(40);
    }
  }
  startGame(lastNeos);
});

/* If fetch fails, generate fake objects */
function generateFakeNeos(n){
  const arr = [];
  for(let i=0;i<n;i++){
    arr.push({
      id: 'fake'+i,
      name: 'FAKE-'+i,
      estimated_diameter: { meters: { estimated_diameter_max: rand(10,300) } },
      close_approach_data: [{ miss_distance: { kilometers: String(rand(1e4,2e7)) }, relative_velocity: { kilometers_per_hour: String(rand(2000,70000)) } }]
    });
  }
  return arr;
}

/* Initial UI default Earth position */
Earth.x = W/2; Earth.y = H/2;

/* Game loop driver: integrates input and frame updating via requestAnimationFrame */
function driver(){
  const t = now();
  const dt = 1/60;
  if(!Earth.dragging && !ai.enabled){
    // apply player keyboard input
    applyPlayerInput(dt);
  }
  setTimeout(driver, 1000/60);
}
driver();

/* update controls (separate from physics loop) */
setInterval(()=>{
  // update settings
  document.getElementById('spawnCount').value = settings.spawnCount;
}, 1000);

/* Draw a preview of positions in startOverlay when lastNeos set (show tiny mini-canvas) */
(function attachPreview(){
  // We already list neos textually; to show a visual preview we can draw markers behind the overlay's list.
  // For simplicity: when fetch completes, show a minimal position map inside startBox (not separate canvas).
  const prev = document.createElement('canvas');
  prev.width = 680; prev.height = 120; prev.style.width='100%'; prev.style.height='120px'; prev.style.marginTop='8px'; prev.style.borderRadius='6px';
  document.getElementById('startBox').appendChild(prev);
  const pctx = prev.getContext('2d');
  function drawPreview(){
    pctx.clearRect(0,0,prev.width,prev.height);
    pctx.fillStyle = '#00161f'; pctx.fillRect(0,0,prev.width,prev.height);
    pctx.fillStyle = '#0d6'; pctx.fillRect(prev.width/2 - 14, prev.height/2 - 14, 28, 28); // Earth
    if(lastNeos){
      const sample = lastNeos.slice(0, Math.min(40, lastNeos.length));
      for(let i=0;i<sample.length;i++){
        const n = sample[i];
        const h = simpleHash(n.id);
        const ang = (h % 360) * Math.PI/180 + (i/sample.length)*0.02;
        const dnorm = Math.min(1, (n.close_approach_data && n.close_approach_data[0] ? parseFloat(n.close_approach_data[0].miss_distance.kilometers) : 1e6)/1e7);
        const r = 30 + (1-dnorm) * (prev.width/2 - 40);
        const x = prev.width/2 + Math.cos(ang)*r;
        const y = prev.height/2 + Math.sin(ang)*r*0.7;
        pctx.fillStyle = '#f5f5f5';
        pctx.beginPath(); pctx.arc(x,y, 2 + (Math.random()*2), 0, Math.PI*2); pctx.fill();
      }
    } else {
      pctx.fillStyle = '#7aa'; pctx.font = '12px Inter, Arial'; pctx.fillText('Click "Fetch Asteroids & Preview" to populate', 12, 20);
    }
    requestAnimationFrame(drawPreview);
  }
  drawPreview();
})();

/* Periodically update physics/animation if running (we use requestAnimationFrame already). */
/* Ensure keyboard movement when not AI: applyPlayerInput is called in driver */

/* Friendly note for user */
console.log('NeoWs Earth Defense demo loaded. Replace API key in the input on the overlay and Fetch/Start.');

/* Small extra helper: keep canvas resolution updated */
function resizeCanvas(){
  W = canvas.width = canvas.clientWidth;
  H = canvas.height = canvas.clientHeight;
  Earth.x = clamp(Earth.x, Earth.r, W-Earth.r);
  Earth.y = clamp(Earth.y, Earth.r, H-Earth.r);
  makeStars();
}
window.addEventListener('resize', resizeCanvas);

</script>
</body>
</html>
